import re
import sys
import os
import platform
import json
import glob
from collections import OrderedDict
from operator import itemgetter
import time
import builtins
from pip._internal import main as _main
import importlib
import xonsh.xontribs
from xonsh.xontribs import xontrib_context, update_context
from prompt_toolkit.formatted_text import FormattedText
from prompt_toolkit.keys import Keys
from xonsh.lazyasd import lazyobject
from collections import Counter
import pickle
import pandas as pd
from os.path import expanduser
from prompt_toolkit import print_formatted_text
from prompt_toolkit.styles import Style
from prompt_toolkit.key_binding.bindings.named_commands import get_by_name
from prompt_toolkit.application.current import get_app
from prompt_toolkit.filters import (Condition, IsMultiline, HasSelection, ViInsertMode)


# --------------------
# ENV and PATH
# --------------------
# bash
source-bash $(/usr/libexec/path_helper -s)
source-bash --seterrprevcmd "" /etc/profile
source-bash @(expanduser('~/homebrew/etc/profile.d/bash_completion.sh'))
for x in glob.glob(expanduser('~/homebrew/etc/bash_completion.d/*')):
    source-bash @(x)
$PATH.append(expanduser('~/.local/bin'))
# nodebrew
$PATH.append(expanduser('~/.nodebrew/current/bin'))
# rbenv
$PATH.append(expanduser('~/.rbenv/bin'))
source-bash $(rbenv init -)
# trans
$PATH.append(expanduser('~/work/bin'))
# docker for mac
$PATH.append('/usr/local/bin')
# homebrew
$PATH.append(expanduser("~/homebrew/bin"))
$PATH.append(expanduser("~/bin"))
# gcloud(install時にPATHを聞かれるのでそこで指定)
$PATH.append(expanduser('~/work/bin/google-cloud-sdk/bin'))
source-bash @(expanduser('~/work/bin/google-cloud-sdk/path.bash.inc'))
source-bash @(expanduser('~/work/bin/google-cloud-sdk/completion.bash.inc'))
# Editor
os.environ.update({'EDITOR': expanduser('~/homebrew/bin/nvim')})
$EDITOR = expanduser('~/homebrew/bin/nvim')
$VISUAL = expanduser('~/homebrew/bin/nvim')
$VI_MODE = False
$COMPLETIONS_CONFIRM = True
$IGNOREEOF = True
$INDENT = "    "
$CASE_SENSITIVE_COMPLETIONS = False
$HISTCONTROL = "ignoredups"
$XONSH_AUTOPAIR = False
$AUTO_CD = True
$XONSH_SHOW_TRACEBACK = True
$SUPPRESS_BRANCH_TIMEOUT_MESSAGE = True
$UPDATE_COMPLETIONS_ON_KEYPRESS = True
$LS_COLORS="di=34:ln=35:so=32:pi=33:ex=31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30"
$XONSH_HISTORY_SIZE = (3000, 'commands')
XONSH_HISTORY_MATCH_ANYWHERE = True
$PTK_STYLE_OVERRIDES={
 "completion-menu": "bg:ansiblack ansiwhite",
 "completion-menu.completion": "bg:ansiblack",
 "completion-menu.completion.current": "bg:ansiwhite ansiblack",
 "scrollbar.background": "bg:ansibrightblack",
 "scrollbar.arrow": "bg:ansiblack ansiwhite bold" ,
 "scrollbar.button": "bg:ansiblack",
 "auto-suggestion": "ansibrightblack",
 "aborting": "ansibrightblack",
 }
$DIR_HIST_PATH = expanduser("~/.dirhist")
$OPEN_FILE_HIST_PATH = expanduser('~/.openfilehist')


# --------------------
# aliases
# --------------------
if platform.system() == 'Darwin':
    aliases["ls"] = "ls -hG"
    aliases["lc"] = "colorls --sf"
    aliases["lt"] = "colorls --tree"
    aliases["l"] = "colorls -ltr --sf"
    aliases["la"] = "colorls -la"
    aliases["ll"] = "colorls -l"
    aliases["lx"] = "colorls -x"
    aliases["lf"] = "colorls -f"
    aliases["ld"] = "colorls -d"
else:
    aliases['ls'] = "ls --color=auto"
    aliases["l"] = "ls -lh"
    aliases["la"] = "ls -lha"
    aliases["ll"] = "ls -lh"
    aliases["sc"] = "screen"
    aliases['free'] = "free -h"
    aliases['f'] = 'free -h'
    aliases['wf'] = 'watch free -h'
aliases['ee'] = "exit"
aliases["ju"] = "jupyter lab"
aliases['jul'] = 'jupyter lab'
aliases["gb"] = "git branch"
aliases["gco"] = "git checkout"
aliases["gd"] = "git diff"
aliases["ga"] = "git add"
aliases["gl"] = "git log"
aliases["gbrowse"] = "git browse-remote"
aliases['gpull'] = 'git pull'
aliases['gclone'] = 'git clone'
aliases["vz"] = "nvim ~/.zshrc"
aliases["vx"] = "nvim ~/.xonshrc"
aliases["vv"] = "nvim ~/.config/nvim"
aliases["vs"] = "nvim ~/.ssh/config"
aliases["v"] = "nvim"
aliases["vi"] = "nvim"
aliases["vim"] = "nvim"
aliases['tardump'] = 'tar -zcvf'
aliases['tarload'] = 'tar -zxvf'
aliases['endless'] = 'caffeinate -d -i -m -u -t 999999'
aliases['kill'] = 'fkill'
aliases['top'] = 'gtop'
aliases['htop'] = 'gtop'


# --------------------
# xontrib
# --------------------
xontrib load z
xontrib load readable-traceback
$READABLE_TRACE_STRIP_PATH_ENV=True
$READABLE_TRACE_REVERSE=True
xontrib load coreutils

# zshから呼び出された場合はpowerline使わない
if 'ZSH_FLAG' in ${...}:
    def get_git_user():
        return '{INTENSE_GREEN}' + $(git config user.name).strip() + ':' + $WORK_MODE +':{curr_branch}{WHITE} ( {YELLOW}"{cwd}" {WHITE}) {INTENSE_RED}$ '
    $PROMPT = get_git_user
else:
    $PL_COLORS = {
            "cwd": ("BLACK", "#a6e22e"),
            "git_root": ("BLUE", ""),
            "git_sub_dir": ("BLACK","")}
    $PL_EXTRA_SEC = {"user": lambda: [' {user} ', 'BLACK', '#fd971f'], "mode": lambda: [f' {$WORK_MODE} ', 'BLACK', '#ae81ff']}
    $PL_PROMPT='user>mode>cwd>branch'
    $PL_TOOLBAR='!'
    $PL_RPROMPT='!'
    xontrib load powerline2


# --------------------
# events
# --------------------

@events.on_chdir
def add_to_file(olddir, newdir, **kw):
    """移動したディレクトリを保存"""
    with open($DIR_HIST_PATH[0], 'a') as dh:
        print(newdir, file=dh)


@events.on_postcommand
def add_to_file(cmd, rtn, out, ts, cwd):
    """vimかopで開いたファイルを保存"""
    if rtn == 0:
        cmd = cmd.strip().split(' ')
        if cmd[0] in ['vim', 'v', 'op'] and len(cmd)==2:
            with open($OPEN_FILE_HIST_PATH[0], 'a') as dh:
                cmd[1] = expanduser(cmd[1]) if '~' in cmd[1] else op.path.join(cwd,cmd[1])
                print(' '.join(cmd), file=dh)

# --------------------
# Keybindings
# --------------------
def _dir_most_common():
    lines = open($dir_hist_path[0]).read().rstrip("\n").split("\n")
    return "\n".join([p for p, c in counter(lines).most_common()])

def _open_file_most_common():
    lines = open($OPEN_FILE_HIST_PATH[0]).read().rstrip("\n").split("\n")
    return "\n".join([p for p, c in counter(lines).most_common()])


@events.on_ptk_create
def custom_keybindings(bindings, **kw):

    @bindings.add('c-v')
    def edit_in_editor(event):
        """コンソール入力をvimで開く"""
        event.current_buffer.tempfile_suffix = '.xsh'
        event.current_buffer.open_in_editor(event.cli)

    @bindings.add('c-r')
    def jump_lastline(event):
        """最終行に飛ぶ"""
        event.current_buffer.cursor_position=len(event.current_buffer.text)

    @bindings.add('c-s')
    def select_ssh(event):
        """ssh先をpecoる"""
        hosts = _get_host(True)
        selected = $(echo @(hosts) | peco)
        if selected:
            event.current_buffer.insert_text('ssh ' + selected.strip().split(', ')[0])

    @bindings.add('c-f')
    def get_auto_suggest(event):
        """suggestの一部確定"""
        b = event.current_buffer
        suggestion = b.suggestion
        if suggestion:
            t = re.split(r'(\S+\s+)', suggestion.text)
            try:
                b.insert_text(next(x for x in t if x))
            except StopIteration:
                pass
            except:
                raise

    @bindings.add('c-o')
    def op_peco(event):
        """opコマンドの挿入と相互変換"""
        t = event.current_buffer.text
        if t=='':
            event.current_buffer.insert_text('op ./')
        else:
            if 'op(' in t:
                event.current_buffer.text = ''
                event.current_buffer.insert_text('op '+t.strip().split('op(')[1].split(')')[0].replace('"', '').replace("'",''))
            elif t.startswith('op '):
                event.current_buffer.text = ''
                event.current_buffer.insert_text('op("'+t.strip().replace('op ', '')+'")')

    @bindings.add('c-d')
    def _dir_most(event):
        """ディレクトリの履歴をpecoる"""
        selected = $(echo @(_dir_most_common()) | peco)
        cd_cmd = "cd " + selected.strip()
        event.current_buffer.insert_text(cd_cmd)

    @bindings.add('c-z')
    def op_peco(event):
        """最近開いたファイルをvimで開くかopコマンドで読み込む"""
        selected = $(echo @(_open_file_most_common()) | peco)
        cd_cmd = selected.strip()
        event.current_buffer.insert_text(cd_cmd)

    @bindings.add('c-t')
    def _engs(event):
        """クリップボードを翻訳コマンド形式で入力"""
        event.current_buffer.insert_text('t """')
        t = $(pbpaste)
        for w in ['#', '@', '>', '*', '"', "'"]:
            t = t.replace(w, ' ')
        t = ' '.join(t.split()).replace('\n', '. ')
        event.current_buffer.insert_text(t)
        event.current_buffer.insert_text('"""')

    @bindings.add('s-left')
    def jump_left(event):
        """vim用ctrlじゃなくshift矢印でword_jump"""
        buff = event.current_buffer
        pos = buff.document.find_previous_word_beginning(count=event.arg, WORD=True)
        if pos:
            buff.cursor_position += pos

    @bindings.add('s-right')
    def jump_right(event):
        """vim用ctrlじゃなくshift矢印でword_jump"""
        buff = event.current_buffer
        pos = buff.document.find_next_word_ending(count=event.arg, WORD=True)
        if pos:
            buff.cursor_position += pos

    @bindings.add('s-up')
    def up_command(event):
        """vim用ctrlじゃなくshift矢印でcommand_jump"""
        get_by_name('previous-history')(event)

    @bindings.add('s-down')
    def down_command(event):
        """vim用ctrlじゃなくshift矢印でcommand_jump"""
        get_by_name('next-history')(event)


# --------------------
# commands
# --------------------
def _git_open():
    """gitをブラウザで開く"""
    open @([x for x in $(git remote show origin).split('\n') if 'URL:' in x][0].split(': ')[1])
aliases['gopen']=_git_open

def _git_add_peco():
    """pecoってgit addする"""
    print('Added:')
    for x in $(git diff --name-only | peco).split('\n'):
        if x:
            cd @($(git rev-parse --show-toplevel).rstrip())
            echo @(x.split())
            git add @(x.split())
aliases['gap']=_git_add_peco


def _git_commit(x):
    """gcコマンド引数を全てメッセージとして連結"""
    if len(x)==0:
        print('set commit message')
        return
    x = ' '.join(x)
    print($(git commit -m @(x)))
aliases["gc"] = _git_commit


def _git_push(x):
    """今いるbranchにpushする"""
    if len(x)==0:
        x = $(git symbolic-ref --short HEAD).replace('\n', '')
        print(f'push branch:{x}? [y/n]', end=':')
        if sys.stdin.readline().replace('\n', '').lower() != 'y':
            return
    else:
        x = x[0]
    print(f'push:{x}')
    git push origin @(x)
aliases["gpush"] = _git_push


def _get_host(color=False):
    """sshホスト一覧を表示したり取得したりする"""
    inquirer_style = Style.from_dict({
        'qa': '#5F819D',
        'qu': '#FF9D00',
        'dp': '#000'
    })
    all_text = ''
    text = ''
    for x in $(cat ~/.ssh/config).split('\n'):
        if 'LocalForward' in x:
            text += ', ' + x.strip().split(' ')[1]
        if 'HostName' in x:
            text += ', ' + x.strip().split(' ')[1]
        elif 'Host ' in x:
            if text!='':
                all_text += text + '\n'
            text = x.split(' ')[1]
    all_text += text + '\n'
    if not color:
        all_d = []
        for x in all_text.split('\n'):
            for i,y in enumerate(x.split(', ')):
                if i==0:
                    all_d.append(('class:qu', y))
                if i==1:
                    all_d.append(('', ', '))
                    all_d.append(('class:qa', y))
                    if len(x.split(', '))==2:
                        all_d.append(('','\n'))
                if i==2:
                    all_d.append(('', ', '))
                    all_d.append(('class:qp', y))
                    all_d.append(('','\n'))
        print_formatted_text(FormattedText(all_d),
                style=inquirer_style)
        return
    return all_text
aliases['host']=_get_host


# _get_host()してparse
def _ssh_host_to_dic():
    host = {}
    for x in _get_host(True).split('\n'):
        rows = x.split(', ')
        if len(rows)>=2:
            host[rows[0]]={'s':rows[1], 'p':None}
        if len(rows)==3:
            host[rows[0]]['p']=rows[2]
    return host

# config生成
def _w_host(host):
    with open('/users/shunsuke.kawai/.ssh/config', 'w') as f:
        f.write('HostKeyAlgorithms +ssh-dss\n')
        f.write('AddKeysToAgent yes\n')
        f.write('host *\n')
        f.write('    ForwardAgent yes\n')
        f.write('    StrictHostKeyChecking no\n')
        for k,v in host.items():
            f.write('\nHost {}\n'.format(k))
            f.write('    HostName {}\n'.format(v['s']))
            if k != 'hoge':
                if k=='kawai':
                    f.write('    User ubuntu\n')
                    f.write('    IdentityFile /users/shunsuke.kawai/.ssh/aws-kawai.pem\n')
                else:
                    f.write('    IdentityFile /users/shunsuke.kawai/.ssh/hinton\n')
                f.write('    IdentitiesOnly yes\n')
                if v['p'] is not None:
                    f.write('    LocalForward {} localhost:{}\n'.format(v['p'],v['p'])) #LocalForward

import argparse
def _update_host(args):
    host = _ssh_host_to_dic()
    parser = argparse.ArgumentParser()
    parser.add_argument('name')
    parser.add_argument('-s')
    parser.add_argument('-p')
    args = parser.parse_args(args)
    if args.name not in host.keys():
        host[args.name]={'s':None, 'p':None}
    if args.s is not None:
        host[args.name]['s'] = args.s
    if args.p is not None:
        host[args.name]['p'] = args.p
    _w_host(host)
aliases['uh'] = _update_host


def _get_history(session_history=None, return_list=False):
    """historyを取得する"""
    hist_dir = __xonsh__.env['XONSH_DATA_DIR']
    files = [ os.path.join(hist_dir,f) for f in os.listdir(hist_dir)
              if f.startswith('xonsh-') and f.endswith('.json') ]
    file_hist = []
    for f in files:
        try:
            file_hist.append(json.load(open(f))['data']['cmds'])
        except:
            pass
    cmds = [ ( c['inp'].replace('\n', ''), c['ts'][0] )
                 for cmds in file_hist for c in cmds if c]
    cmds.sort(key=itemgetter(1))
    cmds = [ c[0] for c in cmds[::-1] ]
    if session_history:
        cmds.extend(session_history)
    # dedupe
    zip_with_dummy = list(zip(cmds, [0] * len(cmds)))[::-1]
    cmds = list(OrderedDict(zip_with_dummy).keys())[::-1]
    cmds = reversed(cmds)
    if return_list:
        return cmds
    else:
        return '\n'.join(cmds)


def _g_change(account):
    """gitのアカウントを変える"""
    account = account[0]
    if account=='vanquish': account='6syun9'
    if account=='shukawai': account='piyo'
    git config --global user.name f"{account}"
    if account=='shukawai':
        git config --global user.email piyo
        print(f'change:{account}')
    elif account=='6syun9':
        git config --global user.email hoge
        print(f'change:{account}')
    else:
        print(f'check account name:{account}')
aliases['gac']=_g_change


jap = re.compile('[あ-んア-ン一-鿐]')
def _eng(x):
    """翻訳コマンド"""
    if len(x)==0: return
    x = ' '.join(x)
    if jap.search(x) is None:
        trans en:ja @(x)
    else:
        echo @(x) | xargs trans ja:en
aliases['t'] = _eng


def op(x):
    '''ファイルをよしなに開くやつ'''
    res = None
    flag = type(x)==list
    if flag:
        x=x[0]
    if not os.path.exists(x):
        print(f'Not found: {x}')
    ext = os.path.splitext(x)[1]
    if ext == '.pkl' or ext == '.pickle':
        with open(x, 'rb') as f:
            res = pickle.load(f)
    elif ext == '.feather':
        res = pd.read_feather(x)
    elif ext == '.csv' or ext == '.txt':
        res = pd.read_csv(x)
    elif ext == '.tsv':
        res = pd.read_csv(x, sep='\t')
    elif ext == '.json':
        with open(x, 'r') as f:
            res = json.load(f)
    else:
        print(f'unkown file type: {x}')
    if flag:
        if type(res) == pd.DataFrame:
            return res.head(10)
        elif type(res) == list:
            return res[:10]
        elif type(res) == dict:
            return {k: v for i, (k, v) in enumerate(res) if i <= 10}
        else:
            return res
    else:
        return res
aliases['op'] = op


def bufappend(self, cmd):
    """historyに特定コマンドを保存しないようにする"""
    if cmd['inp'].strip().split(' ')[0] in ['t', 'ls', 'la', 'l', 'lc', 'lt', 'll', 'lx', 'lf', 'ld']:
        return None
    self.buffer.append(cmd)
    self._len += 1
    if len(self.buffer) >= self.buffersize:
        hf = self.flush()
    else:
        hf = None
    return hf
xonsh.history.json.JsonHistory.append = bufappend


def _mchange(x):
    """開発モードを変更する"""
    if x and x[0] == 'm3':
        cp ~/.config/flake8_m3 ~/.config/flake8
        cp ~/.config/pep8_m3 ~/.config/pep8
        cp ~/.config/pip/pip_m3.conf ~/.config/pip/pip.conf
        cp ~/.config/pycodestyle_m3 ~/.config/pycodestyle
        cp ~/.config/yapf/style_m3 ~/.config/yapf/style
        if os.path.exists(os.environ['HOME']+'/.xonshrc_m3'):
            source ~/.xonshrc_m3
        $WORK_MODE = 'M3'
    else:
        rm ~/.config/flake8
        rm ~/.config/pep8
        rm ~/.config/pip/pip.conf
        rm ~/.config/pycodestyle
        rm ~/.config/yapf/style
        $WORK_MODE = 'Global'
aliases['mc'] = _mchange
$WORK_MODE = 'm3'
mc m3


def _aget():
    t={}
    for x in json.loads($(aws ec2 describe-instances))['Reservations']:
        for y in x['Instances']:
            if y['KeyName']:
                t.update({y['KeyName']: {'dns':y['PublicDnsName'], 'id':y['InstanceId']}})
    return t

def jsonaget():
    return json.dumps(_aget(), indent=4)
aliases['aget'] = jsonaget

def _astop():
    t = _aget()
    aws ec2 stop-instances --instance-ids @(t['aws-kawai']['id'])
aliases['astop'] = _astop

def _astart():
    t = _aget()
    aws ec2 start-instances --instance-ids @(t['aws-kawai']['id'])
aliases['astart'] = _astart

def _ahost():
    t = _aget()
    uh kawai -s @(t['aws-kawai']['dns'])
aliases['ahost'] = _ahost

def _arestart():
    _astop()
    flag = True
    while flag:
        time.sleep(5)
        t = _aget()['aws-kawai']['dns']
        if t=='':
            print('stopped')
            flag = False
    _astart()
    flag = True
    while flag:
        time.sleep(5)
        t = _aget()['aws-kawai']['dns']
        if t!='':
            print('started')
            flag = False
    print('change host')
    _ahost()
    print('success')
aliases['arestart'] = _arestart



def gokart_completer(prefix, line, begidx, endidx, ctx):
    """gokart completer"""
    l = line.split(' ')
    if len(l)>1 and l[0]=='python' and l[1].endswith('.py') and '.' in prefix and len(line[:begidx-1].split(' '))==2:
        sys.path.append('.')
        m = prefix.split('.')[0]
        try:
            module = importlib.import_module(m)
            return set([m+'.'+x for x in dir(module) if not x.startswith('__')])
        except:
            pass
completer add gokart_completer gokart_completer "<import"

def gokart_arg_completer(prefix, line, begidx, endidx, ctx):
    """gokart completer"""
    l = line.split(' ')
    if len(l)>1 and l[0]=='python' and l[1].endswith('.py'):
        return {'--local-scheduler', '--to-date', '--from-date'}
completer add gokart_arg_completer gokart_arg_completer end
